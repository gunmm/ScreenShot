# 设计：可拖拉调整的编辑页视图

## 交互思路 (Draggable Overlay)
原先是每张图有一个独立方块，现在我们必须**将图片拼接展现出来（像拼图游戏一样）**。

### 图像布局 (Layout Strategy)
假设我们有 3 张分片 `[Img1, Img2, Img3]`。
为了不进行高消耗的 CoreGraphics 真正绘制，我们要利用 UIKit 系统进行“视图级拼接”：
1. `UIScrollView` 包裹所有卡片。每个分片对应一个 `UIImageView`。
2. 我们要渲染出“重叠部分被吃掉/被隐藏”的效果。
3. `UIImageView[i]` 的高度固定为按照屏幕宽度的等比缩放计算出的全部原图高度（例如 2000pt）。
4. 裁剪实际上就是控制这个 `UIImageView[i]` 在 `ScrollView` 中实际展示和占据的位置。因为 `UIImageView[i]` 只展示 `range[i].start` 到 `range[i].end`。
5. **Mask 方法**：
   - 包含这个 `UIImageView[i]` 的 `ContainerView[i]` 的 `bounds` 会随着 `range.end - range.start` （换算为 Points，即视图坐标系）的差异发生变化。
   - `UIImageView[i]` 被挂载到 `ContainerView[i]`，但是 `UIImageView[i]` 向上平移（Offset Y 为 `-range.start`），这样，它就正好只显示了这部分。最后设置 `clipsToBounds = true`。 

### 拖拽手柄设计 (Drag Handles)
由于我们目前是各自修剪 `Top Cut` 和 `Bottom Cut`：
- 对于 `Img(i)`，它的底部有一个手柄 `BottomHandle_i`，可以调节本图的 `Bottom Cut`。
- 对于 `Img(i+1)`，它的顶部有一个手柄 `TopHandle_i+1`，可以调节那幅图的 `Top Cut`。

**用户痛点**：由于拼贴的长图追求的是**一张图跟上一张图无缝衔接**，分开调整“上方图的下方裁剪”和“下方图的上方裁剪”太复杂了，而且很多时候它们是一起互动的！

**但是根据现有项目的基础，目前用户最需要的是拖动的直观性。**
为了实现题主“直接在整体拼图上下部分加可以拖动的按钮来调节”：
如果让所有的手柄分散，其实依然不够直观。较佳做法是：
每张图独立配有 **一根可以上下拨动的顶部蓝线 (Top Boundary)** 和 **底部的蓝线 (Bottom Boundary)**。
但既然是将图全貌拼装，其实如果完全盖住，用户看不到被裁剪掉的内容，拉动的时候没法“找回”这部分像素。

#### 优化的“拉窗帘”视图设计：
将所有的图片**完整原图**，用一个小的垂直间距（比如 `spacing = 20`）在 `ScrollView` 排列出来（也就是**不**吸附拼装），仅仅在每张原图上**增加两根半透明的水平拖拽杆（红色的拉杆分别对应 Top Cut 和 Bottom Cut）**，拉杆之间的部分即为被保留的图片。
同时，在屏幕顶部或界面的中心**开一个悬浮小窗 / 或单独的 Preview 模式**，实时展示使用当前截断结果无缝拼凑的样子。
*或者*
在主 ScrollView 里就是拼装好的样子。但当用户长按某一条缝隙（接缝处）时，局部炸开（显示出被吃掉的上下文），允许用户滑动接缝，滑动结束松开即还原组合。

考虑开发复杂度与苹果原生“裁剪图片”（相册的裁剪）的普遍认知，最不奇怪且好做的是：
在原图中悬浮一个带上下边缘（Top/Bottom 把手）的高亮选框。

### 设计决议 (Chosen Path)
- **视觉**：依然类似于之前的“图片列表”，展示所有的 `originalImages`。因为如果不展示原始图片的全貌区域（包括被裁剪的），用户拖动裁剪线没有视觉参考。
- **与之前 Slider 方案的区别**：撤掉难看的 `UISlider`。直接在 `UIImageView` 的内部上方和下方添加带有 `UIPanGestureRecognizer` 的手柄（View）。
- **实时的所见即所得 (WYSIWYG)**：在每一张“可被二次裁切的原图像编辑区块”的边上，不额外做拼图，而是**将 `ScrollView` 和悬浮按钮的“即时验证感”增强**：不再只提供滑块，而是你直接拖动图片上的遮罩边缘，它变灰变亮反馈。
- *甚至可以激进一点*：编辑界面直接是一张连贯的图（不显示冗余部分），但接缝处有一条线。按住那条横线上下拉，这类似于改变拼接位置。（这种做法，相当于一次操作同时增加上图的 BottomCrop 并减小下图的 TopCrop，也就是假定相对位移。目前 OpenCV 自动寻找就是这个目的）。
考虑到 OpenCV 有时判断出来的 offset 是不对的，我们不能只做联动拖动，必须保持独立控制 Top 和 Bottom。

**综合考虑这句“直接在整体拼图的上下部分加两个可以拖动的按钮来调节，拖动然后时实就在编辑页展示调整后的结果页面”**：
用户想要的其实是： **当前展示的是完整拼接结果的长图，但在接缝处可以摸着、拖着调整**。

要实现**“在整体拼图上直接拖动，实时展示”**：
我们创建一堆 Custom View 作为 Container，上下吸附！
- Container0 对应图 0的裁出部分，下面紧接着 Container1 的顶部。
- 每个Container内部依然存放完整的ImageView（向上做了 Offset），只是被 `clipsToBounds`。
- 在接缝（Container(i)和(i+1)的交界）上，放置一个可以摸的水平条。
- 如果拖这根条子向上，说明“接缝上移”。那么 Container(i) 的 Bottom 变小使得它的内容露出的少，而 Container(i+1)的 Top 变小使得它上方补充多。实现了一个“缝隙无损推移”的效果！这其实就是改变图层的相对 `start` 和 `end`！
- 为了照顾所有场景，可能还是必须在每张图的头尾放置独立的手柄。我们将图片拼紧。被裁剪的部分变灰甚至被半隐藏，保留的部分亮着。用户用手直接拖动亮暗交界线的把手。
- 这个把手因为与原图紧密重叠，因此在手指拖动时，`validRanges` 的值被修改，我们立刻调整对应的 `layer.mask` 或 `frame`，用户便立刻看到了新的裁剪范围是如何生效的，因为所有图片的 `ImageView` 在一个叠加在一起实时重绘遮片的容器之中。

具体实现将在 `tasks.md` 中展开详细逻辑。
